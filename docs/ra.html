<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module ra</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="https://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module ra</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>The primary module for interacting with ra servers and clusters.


<h2><a name="description">Description</a></h2>The primary module for interacting with ra servers and clusters.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-environment_param">environment_param()</a></h3>
<p><pre>environment_param() = 
    {data_dir, <a href="file.html#type-filename">file:filename()</a>} |
    {wal_data_dir, <a href="file.html#type-filename">file:filename()</a>} |
    {segment_max_entries, non_neg_integer()} |
    {wal_max_size_bytes, non_neg_integer()} |
    {wal_compute_checksums, boolean()} |
    {wal_write_strategy, default | o_sync}</pre></p>


<h3 class="typedecl"><a name="type-query_fun">query_fun()</a></h3>
<p><pre>query_fun() = 
    fun((term()) -&gt; term()) |
    {M :: module(), F :: atom(), A :: list()}</pre></p>


<h3 class="typedecl"><a name="type-ra_cmd_ret">ra_cmd_ret()</a></h3>
<p><pre>ra_cmd_ret() = <a href="ra_server_proc.html#type-ra_cmd_ret">ra_server_proc:ra_cmd_ret()</a></pre></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#start-0">start/0</a></td><td>Starts the ra application.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Starts the ra application.</td></tr>
<tr><td valign="top"><a href="#start_in-1">start_in/1</a></td><td>Starts the ra application with a provided data directory.</td></tr>
<tr><td valign="top"><a href="#restart_server-1">restart_server/1</a></td><td>Restarts a previously succesfully started ra server.</td></tr>
<tr><td valign="top"><a href="#stop_server-1">stop_server/1</a></td><td>Stops a ra server.</td></tr>
<tr><td valign="top"><a href="#force_delete_server-1">force_delete_server/1</a></td><td>Deletes a ra server
  The server is forcefully deleted.</td></tr>
<tr><td valign="top"><a href="#start_or_restart_cluster-3">start_or_restart_cluster/3</a></td><td>Starts or restarts a ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_cluster-3">start_cluster/3</a></td><td>Starts a new distributed ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_cluster-1">start_cluster/1</a></td><td>Starts a new distributed ra cluster.</td></tr>
<tr><td valign="top"><a href="#start_server-4">start_server/4</a></td><td></td></tr>
<tr><td valign="top"><a href="#start_server-1">start_server/1</a></td><td>Starts a ra server.</td></tr>
<tr><td valign="top"><a href="#delete_cluster-1">delete_cluster/1</a></td><td>Deletes a ra cluster in an orderly fashion
  This function commits and end of life command which after each server applies
  it will cause that server to shut down and delete all it's data.</td></tr>
<tr><td valign="top"><a href="#delete_cluster-2">delete_cluster/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#add_member-2">add_member/2</a></td><td>Add a ra server id to a ra cluster's membership configuration
  This commits a join command to the leader log.</td></tr>
<tr><td valign="top"><a href="#add_member-3">add_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#remove_member-2">remove_member/2</a></td><td>Removes a server from the cluster's membership configuration
  This function returns after appending the command to the log.</td></tr>
<tr><td valign="top"><a href="#remove_member-3">remove_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#trigger_election-1">trigger_election/1</a></td><td>Causes the server to entre the pre-vote and attempt become leader
  It is necessary to call this function when starting a new cluster as a
  branch new ra server will not automatically enter pre-vote by itself.</td></tr>
<tr><td valign="top"><a href="#trigger_election-2">trigger_election/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-1">leave_and_terminate/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-2">leave_and_terminate/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_terminate-3">leave_and_terminate/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_delete_server-1">leave_and_delete_server/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_delete_server-2">leave_and_delete_server/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#leave_and_delete_server-3">leave_and_delete_server/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#new_uid-1">new_uid/1</a></td><td>generates a random uid using the provided source material for the first
  6 characters.</td></tr>
<tr><td valign="top"><a href="#overview-0">overview/0</a></td><td>return a map of overview data of the ra system on the current erlang
  node.</td></tr>
<tr><td valign="top"><a href="#process_command-3">process_command/3</a></td><td>Submits a command to a ra server.</td></tr>
<tr><td valign="top"><a href="#process_command-2">process_command/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#pipeline_command-4">pipeline_command/4</a></td><td>Submits a command to the ra server using a gen_statem:cast passing  
an optional process scoped term as correlation identifier.</td></tr>
<tr><td valign="top"><a href="#pipeline_command-3">pipeline_command/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#pipeline_command-2">pipeline_command/2</a></td><td>Sends a command to the ra server using a gen_statem:cast.</td></tr>
<tr><td valign="top"><a href="#local_query-2">local_query/2</a></td><td>Query the machine state on any server
  This allows you to run the QueryFun over the server machine state and
  return the result.</td></tr>
<tr><td valign="top"><a href="#local_query-3">local_query/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#leader_query-2">leader_query/2</a></td><td>Query the current leader state
  This function works like local_query, but redirects to the current
  leader node.</td></tr>
<tr><td valign="top"><a href="#leader_query-3">leader_query/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#consistent_query-2">consistent_query/2</a></td><td>Query the state machine
  This allows a caller to query the state machine on the leader node with
  an additional heartbeat to check that the node is still the leader.</td></tr>
<tr><td valign="top"><a href="#consistent_query-3">consistent_query/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#members-1">members/1</a></td><td>Query the members of a cluster.</td></tr>
<tr><td valign="top"><a href="#members-2">members/2</a></td><td></td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="start-0">start/0</a></h3>
<div class="spec">
<p><pre>start() -&gt; ok</pre></p>
</div><p>Starts the ra application</p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><pre>start(Params :: [<a href="#type-environment_param">environment_param()</a>]) -&gt;
         {ok, [Started]} | {error, term()}</pre>
<ul class="definitions"><li><pre>Started = term()</pre></li></ul></p>
</div><p>Starts the ra application.
  If the application is running it will be stopped and restarted.</p>

<h3 class="function"><a name="start_in-1">start_in/1</a></h3>
<div class="spec">
<p><pre>start_in(DataDir :: <a href="file.html#type-filename">file:filename()</a>) -&gt;
            {ok, [Started]} | {error, term()}</pre>
<ul class="definitions"><li><pre>Started = term()</pre></li></ul></p>
</div><p>Starts the ra application with a provided data directory.
  The same as ra:start([{data_dir, dir}])
  If the application is running it will be stopped and restarted.</p>

<h3 class="function"><a name="restart_server-1">restart_server/1</a></h3>
<div class="spec">
<p><pre>restart_server(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt; ok | {error, term()}</pre></p>
<p><tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>{ok | error, Error}</code> when error can be
  <code>not_found</code> or <code>name_not_registered</code> when the ra server has never before
  been started on the erlang node.</p>
</div><p>Restarts a previously succesfully started ra server</p>

<h3 class="function"><a name="stop_server-1">stop_server/1</a></h3>
<div class="spec">
<p><pre>stop_server(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt; ok | {error, nodedown}</pre></p>
<p><tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code></p>
</div><p>Stops a ra server</p>

<h3 class="function"><a name="force_delete_server-1">force_delete_server/1</a></h3>
<div class="spec">
<p><pre>force_delete_server(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                       ok | {error, term()}</pre></p>
<p><tt>ServerId</tt>: the ra_server_id() of the server<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code></p>
</div><p>Deletes a ra server
  The server is forcefully deleted.</p>

<h3 class="function"><a name="start_or_restart_cluster-3">start_or_restart_cluster/3</a></h3>
<div class="spec">
<p><pre>start_or_restart_cluster(ClusterName :: <a href="#type-ra_cluster_name">ra_cluster_name()</a>,
                         Machine :: <a href="ra_server.html#type-machine_conf">ra_server:machine_conf()</a>,
                         RemServers :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                            {ok,
                             [<a href="#type-ra_server_id">ra_server_id()</a>],
                             [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                            {error, cluster_not_formed}</pre></p>
<p><tt>ClusterName</tt>: the name of the cluster.<br>
<tt>Machine</tt>: The <a href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If there was no existing cluster and a new cluster could not be formed
  any servers that did manage to start are
  forcefully deleted.</p>
</div><p><p>Starts or restarts a ra cluster.</p>
 
 </p>

<h3 class="function"><a name="start_cluster-3">start_cluster/3</a></h3>
<div class="spec">
<p><pre>start_cluster(ClusterName :: <a href="#type-ra_cluster_name">ra_cluster_name()</a>,
              Machine :: <a href="ra_server.html#type-machine_conf">ra_server:machine_conf()</a>,
              ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                 {ok, [<a href="#type-ra_server_id">ra_server_id()</a>], [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                 {error, cluster_not_formed}</pre></p>
<p><tt>ClusterName</tt>: the name of the cluster.<br>
<tt>Machine</tt>: The <a href="ra_machine.html#machine-0"><code>ra_machine:machine/0</code></a> configuration.<br>
<tt>ServerIds</tt>: The list of ra server ids.<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If a cluster could not be formed any servers that did manage to start are
  forcefully deleted.</p>
</div><p>Starts a new distributed ra cluster.
 </p>

<h3 class="function"><a name="start_cluster-1">start_cluster/1</a></h3>
<div class="spec">
<p><pre>start_cluster(ServerConfigs :: [<a href="ra_server.html#type-ra_server_config">ra_server:ra_server_config()</a>]) -&gt;
                 {ok, [<a href="#type-ra_server_id">ra_server_id()</a>], [<a href="#type-ra_server_id">ra_server_id()</a>]} |
                 {error, cluster_not_formed}</pre></p>
<p><tt>ServerConfigs</tt>: a list of initial server configurations<br>
</p>
<p>returns: <p>
  <code>{ok, Started, NotStarted}</code>  if a cluster could be successfully
  started. A cluster can be successfully started if more than half of the
  servers provided could be started. Servers that could not be started need to
  be retried periodically using <a href="#start_server-1"><code>start_server/1</code></a></p>
 
  <p><code>{error, cluster_not_formed}</code> if a cluster could not be started.</p>
 
  If a cluster could not be formed any servers that did manage to start are
  forcefully deleted.</p>
</div><p>Starts a new distributed ra cluster.
 </p>

<h3 class="function"><a name="start_server-4">start_server/4</a></h3>
<div class="spec">
<p><pre>start_server(ClusterName :: <a href="#type-ra_cluster_name">ra_cluster_name()</a>,
             ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
             Machine :: <a href="ra_server.html#type-machine_conf">ra_server:machine_conf()</a>,
             ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                ok | {error, term()}</pre></p>
</div>

<h3 class="function"><a name="start_server-1">start_server/1</a></h3>
<div class="spec">
<p><pre>start_server(Conf :: <a href="ra_server.html#type-ra_server_config">ra_server:ra_server_config()</a>) -&gt;
                ok | {error, term()}</pre></p>
<p><tt>Conf</tt>: a ra_server_config() configuration map.<br>
</p>
<p>returns: <code>{ok | error, Error}</code></p>
</div><p>Starts a ra server</p>

<h3 class="function"><a name="delete_cluster-1">delete_cluster/1</a></h3>
<div class="spec">
<p><pre>delete_cluster(ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>]) -&gt;
                  {ok, <a href="#type-ra_server_id">ra_server_id()</a>} | {error, term()}</pre></p>
<p><tt>ServerIds</tt>: the ra_server_ids of the cluster<br>
</p>
<p>returns: <code>{ok | error, nodedown}</code></p>
</div><p>Deletes a ra cluster in an orderly fashion
  This function commits and end of life command which after each server applies
  it will cause that server to shut down and delete all it's data.
  The leader will stay up until it has successfully replicated the end of life
  command to all servers after which it too will shut down and delete all it's
  data.</p>

<h3 class="function"><a name="delete_cluster-2">delete_cluster/2</a></h3>
<div class="spec">
<p><pre>delete_cluster(ServerIds :: [<a href="#type-ra_server_id">ra_server_id()</a>],
               Timeout :: timeout()) -&gt;
                  {ok, Leader :: <a href="#type-ra_server_id">ra_server_id()</a>} | {error, term()}</pre></p>
</div>
<p><b>See also:</b> <a href="#delete_cluster-1">delete_cluster/1</a>.</p>

<h3 class="function"><a name="add_member-2">add_member/2</a></h3>
<div class="spec">
<p><pre>add_member(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
           ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
              <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></pre></p>
<p><tt>ServerRef</tt>: the ra server to send the command to<br>
<tt>ServerId</tt>: the ra server id of the new server<br>
</p>
</div><p>Add a ra server id to a ra cluster's membership configuration
  This commits a join command to the leader log. After this has been replicated
  the leader will start replicating entries to the new server.
  This function returns after appending the command to the log.
 </p>

<h3 class="function"><a name="add_member-3">add_member/3</a></h3>
<div class="spec">
<p><pre>add_member(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
           ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
           Timeout :: timeout()) -&gt;
              <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></pre></p>
</div>
<p><b>See also:</b> <a href="#add_member-2">add_member/2</a>.</p>

<h3 class="function"><a name="remove_member-2">remove_member/2</a></h3>
<div class="spec">
<p><pre>remove_member(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
              ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                 <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></pre></p>
<p><tt>ServerRef</tt>: the ra server to send the command to<br>
<tt>ServerId</tt>: the ra server id of the server to remove<br>
</p>
</div><p>Removes a server from the cluster's membership configuration
  This function returns after appending the command to the log.
 </p>

<h3 class="function"><a name="remove_member-3">remove_member/3</a></h3>
<div class="spec">
<p><pre>remove_member(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
              ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
              Timeout :: timeout()) -&gt;
                 <a href="#type-ra_cmd_ret">ra_cmd_ret()</a></pre></p>
</div>
<p><b>See also:</b> <a href="#remove_member-2">remove_member/2</a>.</p>

<h3 class="function"><a name="trigger_election-1">trigger_election/1</a></h3>
<div class="spec">
<p><pre>trigger_election(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt; ok</pre></p>
<p><tt>ServerId</tt>: the ra server id of the server to trigger the election on.<br>
</p>
</div><p>Causes the server to entre the pre-vote and attempt become leader
  It is necessary to call this function when starting a new cluster as a
  branch new ra server will not automatically enter pre-vote by itself.
  Previously started servers will however.
 </p>

<h3 class="function"><a name="trigger_election-2">trigger_election/2</a></h3>
<div class="spec">
<p><pre>trigger_election(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, Timeout :: timeout()) -&gt;
                    ok</pre></p>
</div>

<h3 class="function"><a name="leave_and_terminate-1">leave_and_terminate/1</a></h3>
<div class="spec">
<p><tt>leave_and_terminate(ServerId) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="leave_and_terminate-2">leave_and_terminate/2</a></h3>
<div class="spec">
<p><pre>leave_and_terminate(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
                    ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                       ok | timeout | {error, no_proc}</pre></p>
</div>

<h3 class="function"><a name="leave_and_terminate-3">leave_and_terminate/3</a></h3>
<div class="spec">
<p><pre>leave_and_terminate(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
                    ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                    Timeout :: timeout()) -&gt;
                       ok | timeout | {error, no_proc}</pre></p>
</div>

<h3 class="function"><a name="leave_and_delete_server-1">leave_and_delete_server/1</a></h3>
<div class="spec">
<p><tt>leave_and_delete_server(ServerId) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="leave_and_delete_server-2">leave_and_delete_server/2</a></h3>
<div class="spec">
<p><pre>leave_and_delete_server(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
                        ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
                           ok | timeout | {error, no_proc}</pre></p>
</div>

<h3 class="function"><a name="leave_and_delete_server-3">leave_and_delete_server/3</a></h3>
<div class="spec">
<p><pre>leave_and_delete_server(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>,
                        ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                        Timeout :: timeout()) -&gt;
                           ok | timeout | {error, no_proc}</pre></p>
</div>

<h3 class="function"><a name="new_uid-1">new_uid/1</a></h3>
<div class="spec">
<p><tt>new_uid(Source) -&gt; any()</tt></p>
</div><p>generates a random uid using the provided source material for the first
  6 characters</p>

<h3 class="function"><a name="overview-0">overview/0</a></h3>
<div class="spec">
<p><pre>overview() -&gt; map()</pre></p>
</div><p>return a map of overview data of the ra system on the current erlang
  node.</p>

<h3 class="function"><a name="process_command-3">process_command/3</a></h3>
<div class="spec">
<p><pre>process_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                Command :: term(),
                Timeout :: non_neg_integer()) -&gt;
                   {ok, Reply :: term(), Leader :: <a href="#type-ra_server_id">ra_server_id()</a>} |
                   {error, term()} |
                   {timeout, <a href="#type-ra_server_id">ra_server_id()</a>}</pre></p>
<p><tt>ServerId</tt>: the server id to send the command to<br>
<tt>Command</tt>: an arbitrary term that the state machine can handle<br>
<tt>Timeout</tt>: the time to wait before returning {timeout, ServerId}<br>
</p>
</div><p>Submits a command to a ra server. Returs after the command has
  been applied to the Raft state machine. If the state machine returned a
  response it is included in the second element of the response tuple.
  If the no response was returned the second element is the atom <code>noreply</code>.
  If the server receiving the command isn't the current leader it will
  redirect the call to the leader if known or hold on to the command until
  a leader is known. The leader's server id is returned as the 3rd element
  of the success reply tuple.</p>

<h3 class="function"><a name="process_command-2">process_command/2</a></h3>
<div class="spec">
<p><pre>process_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, Command :: term()) -&gt;
                   {ok, Reply :: term(), Leader :: <a href="#type-ra_server_id">ra_server_id()</a>} |
                   {error, term()} |
                   {timeout, <a href="#type-ra_server_id">ra_server_id()</a>}</pre></p>
</div>

<h3 class="function"><a name="pipeline_command-4">pipeline_command/4</a></h3>
<div class="spec">
<p><pre>pipeline_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                 Command :: term(),
                 Correlation ::
                     <a href="ra_server.html#type-command_correlation">ra_server:command_correlation()</a> |
                     no_correlation,
                 Priority :: normal | low) -&gt;
                    ok</pre></p>
<p><tt>ServerId</tt>: the ra server id to send the command to<br>
<tt>Command</tt>: an arbitrary term that the state machine can handle<br>
<tt>Correlation</tt>: a correlation identifier to be included to receive an
  async notification after the command is applied to the state machine. If the
  Correlation is <code>no_correlation</code> no notifications will be sent.<br>
<tt>Priority</tt>: command priority. <code>low</code> priority commands will be held back
  and appended to the Raft log in batches. NB: A <code>normal</code> priority command sent
  from the same process can overtake a low priority command that was
  sent before. There is no high priority.
  Only use pritory level <code>low</code> for commands where
  total ordering does not matter.<br>
</p>
</div><p><p>Submits a command to the ra server using a gen_statem:cast passing  
an optional process scoped term as correlation identifier.  
A correlation id can be included  
to implement reliable async interactions with the ra system. The calling  
process can retain a map of command that have not yet been applied to the  
state machine successfully and resend them if a notification is not receied  
withing some time window.  
When the command is applied to the state machine the ra server will send  
the calling process a ra_event of the following structure:</p>
 
  <p><code>{ra_event, CurrentLeader, {applied, [{Correlation, Reply}]}}</code></p>
 
  <p>Not that ra will batch notification and thus return a list of correlation  
and result tuples.</p>
 
  <p>If the receving ra server isn't a leader a ra event of the following  
structure will be returned informing the caller that it cannot process the  
message including the current leader, if known:</p>
 
  <p><code>{ra_event, CurrentLeader, {rejected, {not_leader, Leader, Correlation}}}</code>  
The caller can then redirect the command for the correlation identifier to  
the correct ra server.</p>
 
  If insteads the atom <code>no_correlation</code> is used the calling process will not
  receive any notification of command processing success or otherwise.
  This is the
  least reliable way to interact with a ra system and should only be used
  if the command is of little importance.
 </p>

<h3 class="function"><a name="pipeline_command-3">pipeline_command/3</a></h3>
<div class="spec">
<p><pre>pipeline_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
                 Command :: term(),
                 Correlation ::
                     <a href="ra_server.html#type-command_correlation">ra_server:command_correlation()</a> |
                     no_correlation) -&gt;
                    ok</pre></p>
</div>

<h3 class="function"><a name="pipeline_command-2">pipeline_command/2</a></h3>
<div class="spec">
<p><pre>pipeline_command(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, Command :: term()) -&gt;
                    ok</pre></p>
</div><p>Sends a command to the ra server using a gen_statem:cast.
  Effectively the same as
  <code>ra:pipeline_command(ServerId, Command, low, no_correlation)</code>
  This is the least reliable way to interact with a ra system and should only
  be used for commands that are of little importance and where waiting for
  a response is prohibitively slow.</p>

<h3 class="function"><a name="local_query-2">local_query/2</a></h3>
<div class="spec">
<p><pre>local_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, QueryFun :: <a href="#type-query_fun">query_fun()</a>) -&gt;
               <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>({<a href="#type-ra_idxterm">ra_idxterm()</a>,
                                                  term()})</pre></p>
</div><p>Query the machine state on any server
  This allows you to run the QueryFun over the server machine state and
  return the result. Any ra server can be addressed.
  This can return infinitely stale results.</p>

<h3 class="function"><a name="local_query-3">local_query/3</a></h3>
<div class="spec">
<p><pre>local_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
            QueryFun :: <a href="#type-query_fun">query_fun()</a>,
            Timeout :: timeout()) -&gt;
               <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>({<a href="#type-ra_idxterm">ra_idxterm()</a>,
                                                  term()})</pre></p>
</div>

<h3 class="function"><a name="leader_query-2">leader_query/2</a></h3>
<div class="spec">
<p><pre>leader_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>, QueryFun :: <a href="#type-query_fun">query_fun()</a>) -&gt;
                {ok,
                 {<a href="#type-ra_idxterm">ra_idxterm()</a>, term()},
                 <a href="#type-ra_server_id">ra_server_id()</a> | not_known}</pre></p>
</div><p>Query the current leader state
  This function works like local_query, but redirects to the current
  leader node.
  The leader state may be more up-to-date compared to local.
  This function may still return stale results as it reads the current state
  and does not wait for commands to be applied.</p>

<h3 class="function"><a name="leader_query-3">leader_query/3</a></h3>
<div class="spec">
<p><pre>leader_query(ServerId :: <a href="#type-ra_server_id">ra_server_id()</a>,
             QueryFun :: <a href="#type-query_fun">query_fun()</a>,
             Timeout :: timeout()) -&gt;
                {ok,
                 {<a href="#type-ra_idxterm">ra_idxterm()</a>, term()},
                 <a href="#type-ra_server_id">ra_server_id()</a> | not_known}</pre></p>
</div>

<h3 class="function"><a name="consistent_query-2">consistent_query/2</a></h3>
<div class="spec">
<p><pre>consistent_query(Server :: <a href="#type-ra_server_id">ra_server_id()</a>,
                 QueryFun :: <a href="#type-query_fun">query_fun()</a>) -&gt;
                    {ok,
                     Reply :: term(),
                     <a href="#type-ra_server_id">ra_server_id()</a> | not_known}</pre></p>
</div><p>Query the state machine
  This allows a caller to query the state machine on the leader node with
  an additional heartbeat to check that the node is still the leader.
  Consistency guarantee is that the query will return result containing
  at least all changes, committed before this query is issued.
  This may include changes which were committed while the query is running.</p>

<h3 class="function"><a name="consistent_query-3">consistent_query/3</a></h3>
<div class="spec">
<p><pre>consistent_query(Server :: <a href="#type-ra_server_id">ra_server_id()</a>,
                 QueryFun :: <a href="#type-query_fun">query_fun()</a>,
                 Timeout :: timeout()) -&gt;
                    {ok,
                     Reply :: term(),
                     <a href="#type-ra_server_id">ra_server_id()</a> | not_known}</pre></p>
</div>

<h3 class="function"><a name="members-1">members/1</a></h3>
<div class="spec">
<p><pre>members(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>) -&gt;
           <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>([<a href="#type-ra_server_id">ra_server_id()</a>])</pre></p>
</div><p>Query the members of a cluster</p>

<h3 class="function"><a name="members-2">members/2</a></h3>
<div class="spec">
<p><pre>members(ServerRef :: <a href="#type-ra_server_id">ra_server_id()</a>, Timeout :: timeout()) -&gt;
           <a href="ra_server_proc.html#type-ra_leader_call_ret">ra_server_proc:ra_leader_call_ret</a>([<a href="#type-ra_server_id">ra_server_id()</a>])</pre></p>
</div>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="https://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
